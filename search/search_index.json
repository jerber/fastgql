{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FastGQL","text":"<p>FastGQL is a python GraphQL library that uses Pydantic models to build GraphQL types. Think FastAPI for GraphQL.</p> <p><pre><code>from fastapi import FastAPI\nfrom fastgql import GQL, build_router\n\nclass User(GQL):\n    name: str\n    age: int\n\nclass Query(GQL):\n    def user_by_name(self, name: str) -&gt; User:\n        return User(name=name, age=27)\n\nrouter = build_router(query_models=[Query])\n\napp = FastAPI()\n\napp.include_router(router, prefix=\"/graphql\")\n</code></pre> I built FastGQL because I wanted a GraphQL framework that</p> <ol> <li>let me use <code>pydantic.BaseModel</code> objects to define my schema</li> <li>let me build dynamic database queries based on incoming requests</li> </ol> <p>We are now using FastGQL in production and have experienced a massive (10x) speedup in average response times because of 2).</p> <p>You can find out more about how we build dynamic database queries in the Advanced Tutorial section of the docs.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>$ pip install fastgql\n---&gt; 100%\nSuccessfully installed fastgql\n</code></pre>"},{"location":"#example","title":"Example","text":"<p>All you need to do is create objects that inherit from <code>fastgql.GQL</code>, which is a simple subclass of <code>pydantic.BaseModel</code>. For this example, I am creating a mock schema based on movies. For the functions, you'd usually use a database but I hardcoded the data for this example.</p> <p>This code generates a GraphQL schema, reading the object fields and functions. Functions can be sync or async.</p>"},{"location":"#code-it","title":"Code it","text":"<ul> <li>Create a file <code>main.py</code> with:</li> </ul> main.py<pre><code>from uuid import UUID, uuid4\nfrom fastapi import FastAPI\nfrom fastgql import GQL, build_router\n\nclass Account(GQL):  # (4)!\n    id: UUID\n    username: str\n\n    def watchlist(self) -&gt; list[\"Movie\"]:  # (1)!\n        # Usually you'd use a database to get the user's watchlist. For this example, it is hardcoded.\n        return [\n            Movie(id=uuid4(), title=\"Barbie\", release_year=2023),\n            Movie(id=uuid4(), title=\"Oppenheimer\", release_year=2023),\n        ]\n\n    def _secret_function(self) -&gt; str:  # (2)!\n        return \"this is not exposed!\"\n\nclass Person(GQL):\n    id: UUID\n    name: str\n\n    def filmography(self) -&gt; list[\"Movie\"]:\n        return [\n            Movie(id=uuid4(), title=\"Barbie\", release_year=2023),\n            Movie(id=uuid4(), title=\"Wolf of Wallstreet\", release_year=2013),\n        ]\n\nclass Movie(GQL):\n    id: UUID\n    title: str\n    release_year: int\n\n    def actors(self) -&gt; list[\"Person\"]:\n        return [\n            Person(id=uuid4(), name=\"Margot Robbie\"),\n            Person(id=uuid4(), name=\"Ryan Gosling\"),\n        ]\n\nclass Query(GQL):\n    def account_by_username(self, username: str) -&gt; Account:  # (5)!\n        # Usually you'd use a database to get this account. For this example, it is hardcoded.\n        return Account(id=uuid4(), username=username)\n\nrouter = build_router(query_models=[Query])\n\napp = FastAPI()  # (3)!\n\napp.include_router(router, prefix=\"/graphql\")\n</code></pre> <ol> <li>Usually this would be a database call. There is an advanced tutorial showing this.</li> <li>Functions that start with <code>_</code> are not included in the GraphQL schema.</li> <li>This is just a normal FastAPI app. <code>fastgql.build_router</code> returns a router that can be included on any FastAPI app.</li> <li>These objects are subclasses of <code>pydantic.BaseModel</code>, so anything you'd want to do with a <code>BaseModel</code> you can do with these. You'll see how this comes in handy in future tutorials.</li> <li>All of these functions can be sync or async. In a future tutorial I'll use an async database call to get data.</li> </ol>"},{"location":"#run-it","title":"Run it","text":"<p>Run the server with:</p> <pre><code>$ uvicorn main:app --reload\n\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\nINFO:     Started reloader process [28720]\nINFO:     Started server process [28722]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\n</code></pre> (Taken from FastAPI docs) About the command <code>uvicorn main:app --reload</code>...  The command `uvicorn main:app` refers to:  - `main`: the file `main.py` (the Python \"module\"). - `app`: the object created inside of `main.py` with the line `app = FastAPI()`. - `--reload`: make the server restart after code changes. Only do this for development."},{"location":"#check-it","title":"Check it","text":"<p>Open your browser at http://127.0.0.1:8000/graphql.</p> <p>You will see a GraphiQL UI. This is your homebase for creating GraphQL queries and checking the schema.</p> <p></p> <p>You can see the schema, build queries, and access query history from the icons in the top left respectivly. Here is an example query:</p> <p></p>"},{"location":"tutorial/","title":"Intro, Installation, and First Steps","text":"<p>This tutorial assumes you know the basics of GraphQL. If you don't, I suggest checking out this great tutorial first.</p>"},{"location":"tutorial/#create-a-project-and-install-fastgql","title":"Create a project and install FastGQL","text":"<p>Create a folder:</p> <pre><code>mkdir fastgql-tutorial\ncd fastgql-tutorial\n</code></pre> <p>Now, we'll create a virtual environment. This allows us to install python libraries scoped to this project.</p> <p>First, ensure you have a python version of 3.10 or greater. You can check this by running:</p> <pre><code>python --version\n</code></pre> <p>If you do not have python 3.10 or greater, install that now.</p> <pre><code>python -m venv virtualenv\n</code></pre> <p>Now we need to activate the virtual environment.</p> <pre><code>source virtualenv/bin/activate\n</code></pre> <p>Now we can install FastGQL:</p> <pre><code>pip install fastgql\n</code></pre> <p>FastGQL installs with FastAPI and Pydantic V2. You will not need to install a seperate web server library.</p>"},{"location":"tutorial/#define-the-schema","title":"Define the Schema","text":"<p>Info</p> <p>For the sake of simplicity, all code in for this tutorial will be in one file.</p> Full file \ud83d\udc40 <pre><code>from fastapi import FastAPI\nfrom fastgql import GQL, build_router\n\n\nclass Actor(GQL):\n    name: str\n\n\nclass Movie(GQL):\n    title: str\n    release_year: int\n    actors: list[Actor]\n\n\nclass Query(GQL):\n    def get_movies(self) -&gt; list[Movie]:\n        return [\n            Movie(\n                title=\"Barbie\",\n                release_year=2023,\n                actors=[Actor(name=\"Margot Robbie\")],\n            )\n        ]\n\n\nrouter = build_router(query_models=[Query])\n\napp = FastAPI()\n\napp.include_router(router, prefix=\"/graphql\")\n</code></pre> <p>FastGQL works by reading objects inheriting from <code>fastgql.GQL</code> and constructing a GraphQL schema. It reads both the fields and functions of the object. <code>GQL</code> is a simple subclass of <code>pydantic.BaseModel</code> and has all of the functionality of a <code>BaseModel</code>.</p> <p>Even the root <code>Query</code> is a <code>GQL</code> type.</p> <p>Create the file <code>schema.py</code>:</p> schema.py<pre><code>from fastapi import FastAPI\nfrom fastgql import GQL, build_router\n\nclass Actor(GQL):\n    name: str\n\nclass Movie(GQL):\n    title: str\n    release_year: int\n    actors: list[Actor]\n\nclass Query(GQL):\n    def get_movies(self) -&gt; list[Movie]:\n        return [\n            Movie(\n                title=\"Barbie\",\n                release_year=2023,\n                actors=[Actor(name=\"Margot Robbie\")],\n            )\n        ]\n</code></pre>"},{"location":"tutorial/#build-our-schema-and-run-it","title":"Build our schema and run it","text":"<p>Under the hood, FastGQL creates a FastAPI router that executes incoming GraphQL queries. If you're unfamiliar with FastAPI, it is worth checking out their excellent docs.</p> schema.py<pre><code>router = build_router(query_models=[Query]) # (1)!\n\napp = FastAPI() # (2)!\n\napp.include_router(router, prefix=\"/graphql\") # (3)!\n</code></pre> <ol> <li>This is where we build the FastAPI router with our schema</li> <li>Initialize a new FastAPI instance for your app. This can be any app, including one already created elsewhere.</li> <li>Attach the router to the app and include whatever prefix you'd like the GraphQL endpoint to be reached at.</li> </ol> \ud83d\udc40 Full file preview <pre><code>from fastapi import FastAPI\nfrom fastgql import GQL, build_router\n\n\nclass Actor(GQL):\n    name: str\n\n\nclass Movie(GQL):\n    title: str\n    release_year: int\n    actors: list[Actor]\n\n\nclass Query(GQL):\n    def get_movies(self) -&gt; list[Movie]:\n        return [\n            Movie(\n                title=\"Barbie\",\n                release_year=2023,\n                actors=[Actor(name=\"Margot Robbie\")],\n            )\n        ]\n\n\nrouter = build_router(query_models=[Query])\n\napp = FastAPI()\n\napp.include_router(router, prefix=\"/graphql\")\n</code></pre> <p>The easiest way to run this FastAPI server is with Uvicorn, which is a fast async web server.</p> <pre><code>uvicorn schema:app --reload # (1)!\n</code></pre> <ol> <li>A good explaination of Uvicorn can be found here.</li> </ol>"},{"location":"tutorial/#query-it","title":"Query it","text":"<p>It is time to execute your first query! Go to <code>http://0.0.0.0:8000/graphql</code> where you should see a GUI for GraphQL called GraphiQL.</p> <p></p> <p>Paste this query into the text box and hit the play button:</p> <pre><code>{\n  getMovies {\n    title\n    releaseYear\n    actors {\n      name\n    }\n  }\n}\n</code></pre> <p>You should see the data we made in <code>schema.py</code> come back \ud83c\udf89</p> <p></p> <p>Now, we will move on to more advanced tutorials!</p>"},{"location":"tutorial/more_advanced/","title":"Advanced Tutorial","text":"<p>Tip</p> <p>I am still working on the docs. Feel free to DM me on Twitter if you have questions or feedback.</p> <p>The reason I built FastGQL was to address the <code>n+1</code> problem I had with other frameworks.</p> <p>Consider this working example using <code>EdgeDB</code> as the database:</p> Full file \ud83d\udc40 <pre><code>import json\nimport time\nimport typing as T\nfrom uuid import UUID\nimport edgedb\nfrom pydantic import TypeAdapter\nfrom fastapi import FastAPI\nfrom fastgql import GQL, GQLInterface, build_router\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nedgedb_client = edgedb.create_async_client()\n\nContents = list[T.Union[\"Movie\", \"Show\"]]\n\n\nasync def query_required_single_json(\n    name: str, query: str, **variables\n) -&gt; dict[str, T.Any]:\n    start = time.time()\n    res = json.loads(\n        await edgedb_client.query_required_single_json(query=query, **variables)\n    )\n    took_ms = round((time.time() - start) * 1_000, 2)\n    print(f\"[{name}] took {took_ms} ms\")\n    return res\n\n\nclass Account(GQL):\n    id: UUID\n    username: str\n\n    async def watchlist(self, limit: int) -&gt; Contents:\n        q = \"\"\"select Account {\n            watchlist: { id, title, release_year := [is Movie].release_year } limit &lt;int64&gt;$limit\n        } filter .id = &lt;uuid&gt;$id\"\"\"\n        account_d = await query_required_single_json(\n            name=\"account.watchlist\", query=q, id=self.id, limit=limit\n        )\n        return TypeAdapter(Contents).validate_python(account_d[\"watchlist\"])\n\n\nclass Person(GQL):\n    id: UUID\n    name: str\n\n    async def filmography(self) -&gt; Contents:\n        q = \"\"\"select Person {\n            filmography: { id, title, release_year := [is Movie].release_year }\n        } filter .id = &lt;uuid&gt;$id\"\"\"\n        person_d = await query_required_single_json(\n            name=\"person.filmography\", query=q, id=self.id\n        )\n        return TypeAdapter(Contents).validate_python(person_d[\"filmography\"])\n\n\nclass Content(GQLInterface):\n    id: UUID\n    title: str\n\n    async def actors(self) -&gt; list[\"Person\"]:\n        q = \"\"\"select Content { actors: { id, name } } filter .id = &lt;uuid&gt;$id\"\"\"\n        content_d = await query_required_single_json(\n            name=\"content.actors\", query=q, id=self.id\n        )\n        return [Person(**p) for p in content_d[\"actors\"]]\n\n\nclass Movie(Content):\n    release_year: int\n\n\nclass Show(Content):\n    async def seasons(self) -&gt; list[\"Season\"]:\n        q = \"\"\"select Show { season := .&lt;show[is Season] { id, number } } filter .id = &lt;uuid&gt;$id\"\"\"\n        show_d = await query_required_single_json(\n            name=\"show.seasons\", query=q, id=self.id\n        )\n        return [Season(**s) for s in show_d[\"season\"]]\n\n    async def num_seasons(self) -&gt; int:\n        q = \"\"\"select Show { num_seasons } filter .id = &lt;uuid&gt;$id\"\"\"\n        show_d = await query_required_single_json(\n            name=\"show.num_seasons\", query=q, id=self.id\n        )\n        return show_d[\"num_seasons\"]\n\n\nclass Season(GQL):\n    id: UUID\n    number: int\n\n    async def show(self) -&gt; Show:\n        q = \"\"\"select Season { show: { id, title } } filter .id = &lt;uuid&gt;$id\"\"\"\n        season_d = await query_required_single_json(\n            name=\"season.show\", query=q, id=self.id\n        )\n        return Show(**season_d[\"show\"])\n\n\nclass Query(GQL):\n    @staticmethod\n    async def account_by_username(username: str) -&gt; Account:\n        q = \"\"\"select Account { id, username } filter .username = &lt;str&gt;$username\"\"\"\n        account_d = await query_required_single_json(\n            name=\"account_by_username\", query=q, username=username\n        )\n        return Account(**account_d)\n\n\nrouter = build_router(query_models=[Query])\n\napp = FastAPI()\n\napp.include_router(router, prefix=\"/graphql\")\n</code></pre> <p>For each connection, we have to make a new query. For example, if your query is:</p> <pre><code>{\n  accountByUsername(username: \"Cameron\") {\n    id\n    username\n    watchlist(limit: 100) {\n      __typename\n      ...on Movie {\n        id\n        title\n        releaseYear\n        actors {\n          name\n        }\n      }\n      ... on Show {\n        id\n        title\n      }\n    }\n  }\n}\n</code></pre> <p>You get back a lot of nested data. For each nested data you get, that's another database call. For example, to get actors from a movie:</p> <pre><code>class Content(GQLInterface):\n    id: UUID\n    title: str\n\n    async def actors(self) -&gt; list[\"Person\"]:\n        q = \"\"\"select Content { actors: { id, name } } filter .id = &lt;uuid&gt;$id\"\"\"\n        content_d = await query_required_single_json(\n            name=\"content.actors\", query=q, id=self.id\n        )\n        return [Person(**p) for p in content_d[\"actors\"]]\n</code></pre> <p>So, to execute this query, the server had to: 1) get the account by username from the database, 2) get the watchlist of that user from the database, 3) get the actor of each movie from the database</p> <p>There are some solutions to make this process more efficient. One of them is using dataloaders.</p> <p>However, even with a dataloader, you are still making new requests to the database for each new level of data you are requesting.</p> <p>FastGQL comes with a way to solve this problem. It ships with <code>QueryBuilder</code> functionality. This allows you to map your GraphQL schema to your database schema, which means you can dynamically generate the exact database query you need to fulfill the client's request.</p> <p>Note</p> <p>Currently <code>QueryBuilder</code> only works with <code>EdgeDB</code>.</p> <p>Here is a full example of the same schema, now using the <code>QueryBuilder</code> feature.</p> Full file \ud83d\udc40 <pre><code>import json\nimport time\nimport typing as T\nfrom uuid import UUID\nimport edgedb\nfrom fastapi import FastAPI\nfrom fastgql import (\n    GQL,\n    GQLInterface,\n    build_router,\n    Link,\n    Property,\n    get_qb,\n    QueryBuilder,\n    Depends,\n    Info,\n    node_from_path,\n)\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nedgedb_client = edgedb.create_async_client()\n\nContents = list[T.Union[\"Movie\", \"Show\"]]\n\n\ndef parse_raw_content(raw_content: list[dict, T.Any]) -&gt; Contents:\n    w_list: Contents = []\n    for item in raw_content:\n        if item[\"typename\"] == \"default::Movie\":\n            if movie := item.get(\"Movie\"):\n                w_list.append(Movie(**movie))\n        elif item[\"typename\"] == \"default::Show\":\n            if show := item.get(\"Show\"):\n                w_list.append(Show(**show))\n    return w_list\n\n\nasync def query_required_single_json(\n    name: str, query: str, **variables\n) -&gt; dict[str, T.Any]:\n    start = time.time()\n    res = json.loads(\n        await edgedb_client.query_required_single_json(query=query, **variables)\n    )\n    took_ms = round((time.time() - start) * 1_000, 2)\n    print(f\"[{name}] took {took_ms} ms\")\n    return res\n\n\nclass AccountPageInfo(GQL):\n    has_next_page: bool\n    has_previous_page: bool\n    start_cursor: str | None\n    end_cursor: str | None\n\n\nclass AccountEdge(GQL):\n    cursor: str\n    node: \"Account\"\n\n\nclass AccountConnection(GQL):\n    page_info: AccountPageInfo\n    edges: list[AccountEdge]\n    total_count: int\n\n\ndef update_watchlist(child_qb: QueryBuilder, limit: int) -&gt; None:\n    child_qb.set_limit(limit)\n\n\nclass Account(GQL):\n    def __init__(self, **data):\n        super().__init__(**data)\n        self._data = data\n\n    id: T.Annotated[UUID, Property(db_name=\"id\")] = None\n    username: T.Annotated[str, Property(db_name=\"username\")] = None\n\n    async def watchlist(\n        self, info: Info, limit: int\n    ) -&gt; T.Annotated[Contents, Link(db_name=\"watchlist\", update_qbs=update_watchlist)]:\n        return parse_raw_content(raw_content=self._data[info.path[-1]])\n\n\nclass Content(GQLInterface):\n    def __init__(self, **data):\n        super().__init__(**data)\n        self._data = data\n\n    id: T.Annotated[UUID, Property(db_name=\"id\")] = None\n    title: T.Annotated[str, Property(db_name=\"title\")] = None\n\n    async def actors(\n        self, info: Info\n    ) -&gt; T.Annotated[list[\"Person\"], Link(db_name=\"actors\")]:\n        return [Person(**p) for p in self._data[info.path[-1]]]\n\n\nclass Movie(Content):\n    release_year: T.Annotated[int, Property(db_name=\"release_year\")] = None\n\n\nclass Show(Content):\n    num_seasons: T.Annotated[int, Property(db_name=\"num_seasons\")] = None\n\n    async def seasons(\n        self, info: Info\n    ) -&gt; T.Annotated[list[\"Season\"], Link(db_name=\"&lt;show[is Season]\")]:\n        return [Season(**s) for s in self._data[info.path[-1]]]\n\n\nclass Season(GQL):\n    def __init__(self, **data):\n        super().__init__(**data)\n        self._data = data\n\n    id: T.Annotated[UUID, Property(db_name=\"id\")] = None\n    number: T.Annotated[int, Property(db_name=\"number\")] = None\n\n    async def show(self, info: Info) -&gt; T.Annotated[Show, Link(db_name=\"show\")]:\n        return Show(**self._data[info.path[-1]])\n\n\nclass Person(GQL):\n    def __init__(self, **data):\n        super().__init__(**data)\n        self._data = data\n\n    id: T.Annotated[UUID, Property(db_name=\"id\")] = None\n    name: T.Annotated[str, Property(db_name=\"name\")] = None\n\n    async def filmography(\n        self, info: Info\n    ) -&gt; T.Annotated[Contents, Link(db_name=\"filmography\")]:\n        return parse_raw_content(raw_content=self._data[info.path[-1]])\n\n\nAccountEdge.model_rebuild()\n\n\nclass Query(GQL):\n    @staticmethod\n    async def account_by_username(\n        username: str, qb: QueryBuilder = Depends(get_qb)\n    ) -&gt; Account:\n        s, v = qb.build()\n        q = f\"\"\"select Account {s} filter .username = &lt;str&gt;$username\"\"\"\n        print(q)\n        account_d = await query_required_single_json(\n            name=\"account_by_username\", query=q, username=username, **v\n        )\n        return Account(**account_d)\n\n    @staticmethod\n    async def account_connection(\n        info: Info,\n        *,\n        before: str | None = None,\n        after: str | None = None,\n        first: int,\n    ) -&gt; AccountConnection:\n        qb: QueryBuilder = await Account.qb_config.from_info(\n            info=info, node=node_from_path(node=info.node, path=[\"edges\", \"node\"])\n        )\n        qb.fields.add(\"username\")\n        variables = {\"first\": first}\n        filter_list: list[str] = []\n        if before:\n            filter_list.append(\".username &gt; &lt;str&gt;$before\")\n            variables[\"before\"] = before\n        if after:\n            filter_list.append(\".username &lt; &lt;str&gt;$after\")\n            variables[\"after\"] = after\n        if filter_list:\n            filter_s = f'filter {\" and \".join(filter_list)} '\n        else:\n            filter_s = \"\"\n        qb.add_variables(variables, replace=False)\n        s, v = qb.build()\n        q = f\"\"\"\n        with\n            all_accounts := (select Account),\n            _first := &lt;int16&gt;$first,\n            accounts := (select all_accounts {filter_s}order by .username desc limit _first),\n        select {{\n            total_count := count(all_accounts),\n            accounts := accounts {s}\n        }}\n        \"\"\"\n        connection_d = await query_required_single_json(\n            name=\"account_connection\", query=q, **v\n        )\n        total_count = connection_d[\"total_count\"]\n        _accounts = [Account(**d) for d in connection_d[\"accounts\"]]\n        connection = AccountConnection(\n            page_info=AccountPageInfo(\n                has_next_page=len(_accounts) == first and total_count &gt; first,\n                has_previous_page=after is not None,\n                start_cursor=_accounts[0].username if _accounts else None,\n                end_cursor=_accounts[-1].username if _accounts else None,\n            ),\n            total_count=total_count,\n            edges=[\n                AccountEdge(node=account, cursor=account.username)\n                for account in _accounts\n            ],\n        )\n        return connection\n\n\nrouter = build_router(query_models=[Query])\n\napp = FastAPI()\n\napp.include_router(router, prefix=\"/graphql\")\n</code></pre> <p>Now this same query: <pre><code>{\n  accountByUsername(username: \"Cameron\") {\n    id\n    username\n    watchlist(limit: 100) {\n      __typename\n      ...on Movie {\n        id\n        title\n        releaseYear\n        actors {\n          name\n        }\n      }\n      ... on Show {\n        id\n        title\n      }\n    }\n  }\n}\n</code></pre> executes with only one call to the database that looks like this: <pre><code>select Account { id, username, watchlist: { typename := .__type__.name, Movie := (select [is Movie] { __typename := .__type__.name, id, release_year, title, actors: { name } }), Show := (select [is Show] { __typename := .__type__.name, id, title }) } LIMIT &lt;int32&gt;$limit } filter .username = &lt;str&gt;$username\n</code></pre></p> <p>The original query took around 180ms to execute and make 6 database calls.</p> <p>The new query using <code>QueryBuilders</code> takes less than 30ms to execute and only makes one database call!</p> <p>For this small example, the results are not so dramatic. But in production, on large datasets, the speed advantage can easily be 10x.</p>"},{"location":"tutorial/query_builder/","title":"Query Builder Tutorial","text":"<p>I will be adding this later. Please dm me on twitter if you'd like me to make it sooner.</p>"}]}